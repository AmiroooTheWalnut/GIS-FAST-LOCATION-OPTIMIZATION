/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package esmaieeli.gisFastLocationOptimization.GUI;

import esmaieeli.gisFastLocationOptimization.Clustering.CLOPERevised;
import esmaieeli.gisFastLocationOptimization.Clustering.Cluster;
import esmaieeli.gisFastLocationOptimization.Clustering.LVQRevised;
import esmaieeli.gisFastLocationOptimization.Clustering.SOMRevised;
import esmaieeli.gisFastLocationOptimization.GIS3D.LayerDefinition;
import esmaieeli.gisFastLocationOptimization.GIS3D.ReportResults;
import java.awt.Color;
import java.awt.Dimension;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JCheckBox;
import javax.swing.JFileChooser;
import javax.swing.table.DefaultTableModel;
import weka.clusterers.CLOPE;
import weka.clusterers.Canopy;
import weka.clusterers.CascadeSimpleKMeans;
import weka.clusterers.ClusterEvaluation;
import weka.clusterers.Cobweb;
import weka.clusterers.EM;
import weka.clusterers.LVQ;
import weka.clusterers.MakeDensityBasedClusterer;
import weka.clusterers.SelfOrganizingMap;
import weka.clusterers.SimpleKMeans;
import weka.clusterers.XMeans;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.converters.AbstractFileLoader;
import weka.core.converters.ArffLoader.ArffReader;
import weka.gui.ConverterFileChooser;
import weka.gui.explorer.ExplorerDefaults;

/**
 *
 * @author Amir72c
 */
public class ClusteringDialog extends javax.swing.JDialog {

    protected Instances m_Instances;
    protected ConverterFileChooser m_FileChooser = new ConverterFileChooser(new File(ExplorerDefaults.getInitialDirectory()));
    MainFramePanel myParent;
    JCheckBox checkBoxes[];
    String data[][];
    String headers[];
    ReportResults localReport;

    /**
     * Creates new form ClusteringDialog
     */
    public ClusteringDialog(java.awt.Window window, MainFramePanel parent, ModalityType modal) {
        super(window, modal);
        initComponents();
        myParent = parent;
        myParent.baseDataDetails.refreshTable();
        checkBoxes = new JCheckBox[myParent.allData.all_Layers.size()];
        for (int i = 0; i < checkBoxes.length; i++) {
            checkBoxes[i] = new javax.swing.JCheckBox();
            checkBoxes[i].setSelected(true);
            checkBoxes[i].setText(((LayerDefinition) myParent.allData.all_Layers.get(i)).layerName);
            checkBoxes[i].setBounds(0, i * 16, 100, 16);
            checkBoxes[i].setVisible(true);
            jPanel5.add(checkBoxes[i]);
        }
        jPanel5.setPreferredSize(new Dimension(110, checkBoxes.length * 16));

        jTable1.setModel(new javax.swing.table.DefaultTableModel(data, headers));

        //jCheckBox1 = new javax.swing.JCheckBox();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jPanel2 = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();
        jCheckBox1 = new javax.swing.JCheckBox();
        prepareData = new javax.swing.JButton();
        jPanel4 = new javax.swing.JPanel();
        runAll = new javax.swing.JButton();
        runXMeans = new javax.swing.JButton();
        runDBSCAN = new javax.swing.JButton();
        runSOM = new javax.swing.JButton();
        runCKM = new javax.swing.JButton();
        runEM = new javax.swing.JButton();
        runCan = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jPanel3 = new javax.swing.JPanel();
        jButton4 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        jPanel5 = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane1.setViewportView(jTable1);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane2.setViewportView(jTextArea1);

        jPanel2.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        jButton1.setText("OpenExternal");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jCheckBox1.setSelected(true);
        jCheckBox1.setText("Auto detect weight");

        prepareData.setText("Prepare data");
        prepareData.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                prepareDataActionPerformed(evt);
            }
        });

        jPanel4.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        runAll.setText("Run all");
        runAll.setEnabled(false);
        runAll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runAllActionPerformed(evt);
            }
        });

        runXMeans.setText("Run XMeans");
        runXMeans.setEnabled(false);
        runXMeans.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runXMeansActionPerformed(evt);
            }
        });

        runDBSCAN.setText("Run DBC");
        runDBSCAN.setEnabled(false);
        runDBSCAN.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runDBSCANActionPerformed(evt);
            }
        });

        runSOM.setText("Run SOM");
        runSOM.setEnabled(false);
        runSOM.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runSOMActionPerformed(evt);
            }
        });

        runCKM.setText("Run CascadeKM");
        runCKM.setEnabled(false);
        runCKM.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runCKMActionPerformed(evt);
            }
        });

        runEM.setText("Run EM");
        runEM.setEnabled(false);
        runEM.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runEMActionPerformed(evt);
            }
        });

        runCan.setText("Run Canopy");
        runCan.setEnabled(false);
        runCan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runCanActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(runAll)
                    .addComponent(runXMeans)
                    .addComponent(runDBSCAN)
                    .addComponent(runSOM)
                    .addComponent(runCKM)
                    .addComponent(runEM)
                    .addComponent(runCan))
                .addContainerGap(26, Short.MAX_VALUE))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(runAll)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(runXMeans)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(runDBSCAN)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(runSOM)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(runCKM)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(runEM)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(runCan)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBox1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 119, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton1, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(prepareData, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButton1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(prepareData)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBox1)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jButton4.setText("Deselect all");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jButton3.setText("Select all");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton4, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jButton3, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButton3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton4)
                .addContainerGap())
        );

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 268, Short.MAX_VALUE)
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 314, Short.MAX_VALUE)
        );

        jScrollPane3.setViewportView(jPanel5);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane3)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane3)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 377, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 249, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addComponent(jScrollPane2)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        setInstancesFromFileQ();
    }//GEN-LAST:event_jButton1ActionPerformed

    private void runAllActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runAllActionPerformed
        // TODO add your handling code here:
        readData();

        //REPORTING
        String detailedResults = "Running all available clustering algorithms on selected mixed layer."+System.lineSeparator();
        Calendar currentDate=Calendar.getInstance();
        Date date=currentDate.getTime();
        double startRAM=(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory())/1024.0;
        long startTime=System.nanoTime();
        //REPORTING

        EM em = new EM();
        SimpleKMeans kmeans = new SimpleKMeans();

        MakeDensityBasedClusterer dbscan = new MakeDensityBasedClusterer();

        Canopy canopy = new Canopy();

        Cobweb cobWeb = new Cobweb();

        XMeans xMeans = new XMeans();

        CascadeSimpleKMeans cascadeSimpleKMeans = new CascadeSimpleKMeans();

        LVQRevised lvq = new LVQRevised();

        SOMRevised selfOrganizingMap = new SOMRevised();

        CLOPERevised clop = new CLOPERevised();

        try {
            //xMeans.setNumExecutionSlots(Runtime.getRuntime().availableProcessors());
            long start = System.nanoTime();
            xMeans.setMaxNumClusters(20);
            xMeans.setMinNumClusters(3);
            xMeans.setUseKDTree(false);
            xMeans.setMaxIterations(200);
            xMeans.setMaxKMeans(2000);
            xMeans.setMaxKMeansForChildren(2000);
            xMeans.setCutOffFactor(0.5);
            xMeans.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(xMeans);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("XMeans");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "XMeans");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);

            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }

        try {
            long start = System.nanoTime();
            XMeans subClusterer = new XMeans();
            subClusterer.setMinNumClusters(3);
            subClusterer.setMaxNumClusters(20);
            dbscan.setClusterer(subClusterer);
            dbscan.setMinStdDev(0.0001);
            dbscan.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(dbscan);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("DBSCAN");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "DBSCAN");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);
            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }

        //NO WEIGHT,NO OPTIMAL CLUSTER
//            try {
//                //cascadeSimpleKMeans.setNumExecutionSlots(Runtime.getRuntime().availableProcessors());
//                lvq.setNumOfClusters(4);
//                lvq.setNormalizeAttributes(true);
//                lvq.setCalcStats(true);
//                lvq.setLearningRate(0.5);
//                lvq.buildClusterer(m_Instances);
//                ClusterEvaluation eval = new ClusterEvaluation();
//                eval.setClusterer(lvq);
//                eval.evaluateClusterer(m_Instances);
//                String strSummary = eval.clusterResultsToString();
//                System.out.println("LVQ");
//                System.out.println(strSummary);
//                double[] assignments=eval.getClusterAssignments();
//                LayerDefinition cluster=new LayerDefinition("category","LVQ");
//                cluster.categories=new String[eval.getNumClusters()];
//                cluster.values=new double[eval.getNumClusters()];
//                cluster.colors=new Color[eval.getNumClusters()];
//                for (int i = 0; i < eval.getNumClusters(); i++) {
//                    cluster.categories[i]=String.valueOf(i);
//                    cluster.values[i]=i+1;
//                    cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
//                }
//                myParent.allData.all_Layers.add(cluster);
//                
//                for(int i=0;i<myParent.allData.all_Nodes.length;i++)
//                {
//                    short[] temp = new short[1];
//                    temp[0]=(short)(assignments[i]+1);
//                    myParent.allData.all_Nodes[i].layers.add(temp);
//                }
//            } catch (Exception ex) {
//                System.out.println(ex.getMessage());
//            }

        //VERY POOR
//            try {
//                //clop.setNumExecutionSlots(Runtime.getRuntime().availableProcessors());
//                clop.setRepulsion(1);
//                clop.buildClusterer(m_Instances);
//                ClusterEvaluation eval = new ClusterEvaluation();
//                eval.setClusterer(clop);
//                eval.evaluateClusterer(m_Instances);
//                String strSummary = eval.clusterResultsToString();
//                System.out.println("clop");
//                System.out.println(strSummary);
//                double[] assignments=eval.getClusterAssignments();
//                LayerDefinition cluster=new LayerDefinition("category","clop");
//                cluster.categories=new String[eval.getNumClusters()];
//                cluster.values=new double[eval.getNumClusters()];
//                cluster.colors=new Color[eval.getNumClusters()];
//                for (int i = 0; i < eval.getNumClusters(); i++) {
//                    cluster.categories[i]=String.valueOf(i);
//                    cluster.values[i]=i+1;
//                    cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
//                }
//                myParent.allData.all_Layers.add(cluster);
//                for(int i=0;i<myParent.allData.all_Nodes.length;i++)
//                {
//                    short[] temp = new short[1];
//                    temp[0]=(short)(assignments[i]+1);
//                    myParent.allData.all_Nodes[i].layers.add(temp);
//                }
//            } catch (Exception ex) {
//                System.out.println(ex.getMessage());
//            }

        try {
            //cascadeSimpleKMeans.setNumExecutionSlots(Runtime.getRuntime().availableProcessors());
//                selfOrganizingMap.setHeight(3);
//                selfOrganizingMap.setWidth(3);
            long start = System.nanoTime();
            selfOrganizingMap.setOrderingEpochs(500);
            selfOrganizingMap.setConvergenceEpochs(500);
            selfOrganizingMap.setCalcStats(false);
            selfOrganizingMap.setNormalizeAttributes(false);
            selfOrganizingMap.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(selfOrganizingMap);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("selfOrganizingMap");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "selfOrganizingMap");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);

            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }

        try {
            //cascadeSimpleKMeans.setNumExecutionSlots(Runtime.getRuntime().availableProcessors());
            long start = System.nanoTime();
            cascadeSimpleKMeans.setMaxNumClusters(15);
            cascadeSimpleKMeans.setMinNumClusters(3);
            cascadeSimpleKMeans.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(cascadeSimpleKMeans);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("CascadeSimpleKMeans");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "cascadeSimpleKMeans");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);
            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        //TOO SLOW
//            try {
//                //cobWeb.setNumExecutionSlots(Runtime.getRuntime().availableProcessors());
//                //cobWeb.setMaximumNumberOfClusters(20);
//                cobWeb.buildClusterer(m_Instances);
//                ClusterEvaluation eval = new ClusterEvaluation();
//                eval.setClusterer(cobWeb);
//                eval.evaluateClusterer(m_Instances);
//                String strSummary = eval.clusterResultsToString();
//                System.out.println("CobWeb");
//                System.out.println(strSummary);
//                double[] assignments=eval.getClusterAssignments();
//                LayerDefinition cluster=new LayerDefinition("category","CobWeb");
//                cluster.categories=new String[eval.getNumClusters()];
//                cluster.values=new double[eval.getNumClusters()];
//                cluster.colors=new Color[eval.getNumClusters()];
//                for (int i = 0; i < eval.getNumClusters(); i++) {
//                    cluster.categories[i]=String.valueOf(i);
//                    cluster.values[i]=i+1;
//                    cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
//                }
//                myParent.allData.all_Layers.add(cluster);
//                for(int i=0;i<myParent.allData.all_Nodes.length;i++)
//                {
//                    short[] temp = new short[1];
//                    temp[0]=(short)(assignments[i]+1);
//                    myParent.allData.all_Nodes[i].layers.add(temp);
//                }
//            } catch (Exception ex) {
//                System.out.println(ex.getMessage());
//            }
        try {
            long start = System.nanoTime();
            em.setNumExecutionSlots(6);
            em.setMaxIterations(40);
            em.setMinLogLikelihoodImprovementCV(0.001);
            em.setMinLogLikelihoodImprovementIterating(0.001);
            em.setMinStdDev(0.001);
            em.setMaximumNumberOfClusters(20);
            em.setMinLogLikelihoodImprovementCV(0.001);
            em.setMinStdDev(0.001);
//                em.setNumFolds(2);
//                em.setNumKMeansRuns(1);
//                em.setMaxIterations(1);
//                em.setMinStdDev(10);
//                em.setNumClusters(3);
            em.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(em);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("EM");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "EM");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);
            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
//            for(int i=3;i<20;i++)
//            {
//                try {
//                kmeans.setNumExecutionSlots(Runtime.getRuntime().availableProcessors());
//                kmeans.setNumClusters(i);
//                kmeans.setPreserveInstancesOrder(true);
//                kmeans.buildClusterer(m_Instances);
//                System.out.println("cluster number: "+i);
//                System.out.println("SE: "+kmeans.getSquaredError());
//                double CNum[]=kmeans.getClusterSizes();
//                //double dunnIndex=dunnIndexCalc(kmeans);
//                //System.out.println("Dunn Index: "+dunnIndex);
//                for(int j=0;j<CNum.length;j++)
//                {
////                    System.out.println("Cluster "+j);
////                    System.out.println("Number "+CNum[j]);
//                }
//                //ClusterEvaluation eval = new ClusterEvaluation();
//                //eval.setClusterer(kmeans);
//                //eval.evaluateClusterer(m_Instances);
//                //String strSummary = eval.clusterResultsToString();
//                //System.out.println("K-means");
//                //System.out.println(strSummary);
//            } catch (Exception ex) {
//                System.out.println(ex.getMessage());
//            }
//            }


        try {
//                canopy.setNumExecutionSlots(Runtime.getRuntime().availableProcessors());
            long start = System.nanoTime();
            canopy.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(canopy);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("Canopy");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "canopy");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);
            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }

        //REPORTING
        long endTime = System.nanoTime();
        double elapsed = ((endTime - startTime) / 1000000000);
        double endRAM = (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1024.0;
        double usedRAM = endRAM - startRAM;
        localReport = new ReportResults(date, "Clustering all algorithms", startTime, endTime, elapsed, 1, startRAM, endRAM, usedRAM, detailedResults);
        myParent.allData.results.add(localReport);
        myParent.refreshReportList();
        //REPORTING

    }//GEN-LAST:event_runAllActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        // TODO add your handling code here:
        for (int i = 0; i < checkBoxes.length; i++) {
            checkBoxes[i].setSelected(true);
        }
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        // TODO add your handling code here:
        for (int i = 0; i < checkBoxes.length; i++) {
            checkBoxes[i].setSelected(false);
        }
    }//GEN-LAST:event_jButton4ActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        // TODO add your handling code here:
    }//GEN-LAST:event_formWindowClosing

    private void prepareDataActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_prepareDataActionPerformed
        // TODO add your handling code here:
        data = new String[myParent.baseDataDetails.data.length][3];
        headers = new String[3];
        headers[0] = myParent.baseDataDetails.headers[1];
        headers[1] = myParent.baseDataDetails.headers[2];
        headers[2] = "Weight";
        for (int i = 0; i < myParent.baseDataDetails.data.length; i++) {
            //System.out.println("data columns: "+myParent.baseDataDetails.data[i].length);
            data[i][0] = myParent.baseDataDetails.data[i][1];
            data[i][1] = myParent.baseDataDetails.data[i][2];
            data[i][2] = "";
        }
        if (jCheckBox1.isSelected() == true) {
            int weightLayerIndex = -1;
            for (int i = 0; i < myParent.baseDataDetails.headers.length; i++) {
                if (myParent.baseDataDetails.headers[i].toLowerCase().contains("allmixed")) {
                    weightLayerIndex = i;
                }
            }
            for (int i = 0; i < myParent.baseDataDetails.data.length; i++) {
                if (Double.valueOf(myParent.baseDataDetails.data[i][weightLayerIndex]) < 0) {
                    data[i][2] = String.valueOf(0);
                } else {
                    data[i][2] = String.valueOf(myParent.baseDataDetails.data[i][weightLayerIndex]);
                }
            }
            DefaultTableModel model = new javax.swing.table.DefaultTableModel(data, headers);
            jTable1.setModel(model);

            model.fireTableDataChanged();
        } else {
            ArrayList acceptedLayerIndexs = new ArrayList();
            for (int i = 0; i < checkBoxes.length; i++) {
                if (checkBoxes[i].isSelected()) {
                    acceptedLayerIndexs.add(i);
                }
            }
            for (int i = 0; i < myParent.baseDataDetails.data.length; i++) {
                double weight = 0;
                for (int j = 0; j < acceptedLayerIndexs.size(); j++) {
                    if (((LayerDefinition) myParent.allData.all_Layers.get((int) acceptedLayerIndexs.get(j))).isBenefit == true) {
                        int num_categories = ((LayerDefinition) myParent.allData.all_Layers.get((int) acceptedLayerIndexs.get(j))).categories.length;
                        double step = (double) 1 / (double) num_categories;
                        double addedWeight = Double.parseDouble(myParent.baseDataDetails.data[i][(int) acceptedLayerIndexs.get(j)]) * step;
                        weight = weight + addedWeight;
//                    System.out.println(addedWeight);
                    } else if (((LayerDefinition) myParent.allData.all_Layers.get((int) acceptedLayerIndexs.get(j))).isBenefit == false) {
                        int num_categories = ((LayerDefinition) myParent.allData.all_Layers.get((int) acceptedLayerIndexs.get(j))).categories.length;
                        double step = (double) 1 / (double) num_categories;
                        double addedWeight = 1 - Double.parseDouble(myParent.baseDataDetails.data[i][(int) acceptedLayerIndexs.get(j) + 1]) * step;
                        weight = weight + addedWeight;
//                    System.out.println(addedWeight);
                    }
                }
                weight = weight / (double) acceptedLayerIndexs.size();
//            System.out.println(weight);
                if (weight < 0) {
                    data[i][2] = String.valueOf(0);
                } else {
                    data[i][2] = String.valueOf(weight);
                }
            }
            jTable1.setModel(new javax.swing.table.DefaultTableModel(data, headers));
        }
        System.out.println("WEIGHT READY!");
        runAll.setEnabled(true);
        runXMeans.setEnabled(true);
        runDBSCAN.setEnabled(true);
        runSOM.setEnabled(true);
        runCKM.setEnabled(true);
        runEM.setEnabled(true);
        runCan.setEnabled(true);
    }//GEN-LAST:event_prepareDataActionPerformed

    private void runXMeansActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runXMeansActionPerformed
        // TODO add your handling code here:
        readData();
        
        //REPORTING
        String detailedResults = "Running Xmeans algorithm on selected mixed layer."+System.lineSeparator();
        Calendar currentDate=Calendar.getInstance();
        Date date=currentDate.getTime();
        double startRAM=(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory())/1024.0;
        long startTime=System.nanoTime();
        //REPORTING
        
        XMeans xMeans = new XMeans();
        try {
            //xMeans.setNumExecutionSlots(Runtime.getRuntime().availableProcessors());
            long start = System.nanoTime();
            xMeans.setMaxNumClusters(20);
            xMeans.setMinNumClusters(3);
            xMeans.setUseKDTree(false);
            xMeans.setMaxIterations(500);
            xMeans.setMaxKMeans(5000);
            xMeans.setMaxKMeansForChildren(5000);
            xMeans.setCutOffFactor(0.5);
            xMeans.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(xMeans);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("XMeans");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "XMeans");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);

            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        
        //REPORTING
        long endTime = System.nanoTime();
        double elapsed = ((endTime - startTime) / 1000000000);
        double endRAM = (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1024.0;
        double usedRAM = endRAM - startRAM;
        localReport = new ReportResults(date, "Xmeans clustering", startTime, endTime, elapsed, 1, startRAM, endRAM, usedRAM, detailedResults);
        myParent.allData.results.add(localReport);
        myParent.refreshReportList();
        //REPORTING
    }//GEN-LAST:event_runXMeansActionPerformed

    private void runDBSCANActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runDBSCANActionPerformed
        // TODO add your handling code here:
        readData();
        
        //REPORTING
        String detailedResults = "Running DBSCAN algorithm on selected mixed layer."+System.lineSeparator();
        Calendar currentDate=Calendar.getInstance();
        Date date=currentDate.getTime();
        double startRAM=(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory())/1024.0;
        long startTime=System.nanoTime();
        //REPORTING
        
        MakeDensityBasedClusterer dbscan = new MakeDensityBasedClusterer();
        try {
            long start = System.nanoTime();
            XMeans subClusterer = new XMeans();
            subClusterer.setMinNumClusters(3);
            subClusterer.setMaxNumClusters(20);
            dbscan.setClusterer(subClusterer);
            dbscan.setMinStdDev(0.0001);
            dbscan.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(dbscan);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("DBSCAN");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "DBSCAN");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);
            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        //REPORTING
        long endTime = System.nanoTime();
        double elapsed = ((endTime - startTime) / 1000000000);
        double endRAM = (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1024.0;
        double usedRAM = endRAM - startRAM;
        localReport = new ReportResults(date, "DBSCAN clustering", startTime, endTime, elapsed, 1, startRAM, endRAM, usedRAM, detailedResults);
        myParent.allData.results.add(localReport);
        myParent.refreshReportList();
        //REPORTING
    }//GEN-LAST:event_runDBSCANActionPerformed

    private void runSOMActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runSOMActionPerformed
        // TODO add your handling code here:
        readData();
        //REPORTING
        String detailedResults = "Running SOM algorithm on selected mixed layer."+System.lineSeparator();
        Calendar currentDate=Calendar.getInstance();
        Date date=currentDate.getTime();
        double startRAM=(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory())/1024.0;
        long startTime=System.nanoTime();
        //REPORTING
        SOMRevised selfOrganizingMap = new SOMRevised();
        try {
            long start = System.nanoTime();
//            selfOrganizingMap.setHeight(10);
//            selfOrganizingMap.setWidth(10);
            selfOrganizingMap.setOrderingEpochs(500);
            selfOrganizingMap.setConvergenceEpochs(500);
            selfOrganizingMap.setCalcStats(false);
//            selfOrganizingMap.setNormalizeAttributes(false);
            selfOrganizingMap.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(selfOrganizingMap);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("selfOrganizingMap");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "selfOrganizingMap");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);

            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        //REPORTING
        long endTime = System.nanoTime();
        double elapsed = ((endTime - startTime) / 1000000000);
        double endRAM = (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1024.0;
        double usedRAM = endRAM - startRAM;
        localReport = new ReportResults(date, "SOM clustering", startTime, endTime, elapsed, 1, startRAM, endRAM, usedRAM, detailedResults);
        myParent.allData.results.add(localReport);
        myParent.refreshReportList();
        //REPORTING
    }//GEN-LAST:event_runSOMActionPerformed

    private void runCKMActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runCKMActionPerformed
        // TODO add your handling code here:
        readData();
        //REPORTING
        String detailedResults = "Running CascadeKM algorithm on selected mixed layer."+System.lineSeparator();
        Calendar currentDate=Calendar.getInstance();
        Date date=currentDate.getTime();
        double startRAM=(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory())/1024.0;
        long startTime=System.nanoTime();
        //REPORTING
        CascadeSimpleKMeans cascadeSimpleKMeans = new CascadeSimpleKMeans();
        try {
            long start = System.nanoTime();
            cascadeSimpleKMeans.setMaxNumClusters(20);
            cascadeSimpleKMeans.setMinNumClusters(3);
            cascadeSimpleKMeans.setRestarts(20);
            cascadeSimpleKMeans.setInitializeUsingKMeansPlusPlusMethod(true);
            cascadeSimpleKMeans.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(cascadeSimpleKMeans);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("CascadeSimpleKMeans");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "cascadeSimpleKMeans");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);
            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        //REPORTING
        long endTime = System.nanoTime();
        double elapsed = ((endTime - startTime) / 1000000000);
        double endRAM = (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1024.0;
        double usedRAM = endRAM - startRAM;
        localReport = new ReportResults(date, "CascadeKM clustering", startTime, endTime, elapsed, 1, startRAM, endRAM, usedRAM, detailedResults);
        myParent.allData.results.add(localReport);
        myParent.refreshReportList();
        //REPORTING
    }//GEN-LAST:event_runCKMActionPerformed

    private void runEMActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runEMActionPerformed
        // TODO add your handling code here:
        readData();
        //REPORTING
        String detailedResults = "Running EM algorithm on selected mixed layer."+System.lineSeparator();
        Calendar currentDate=Calendar.getInstance();
        Date date=currentDate.getTime();
        double startRAM=(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory())/1024.0;
        long startTime=System.nanoTime();
        
        detailedResults=detailedResults+"Max iterations: "+50+System.lineSeparator();
        detailedResults=detailedResults+"Max clusters: "+25+System.lineSeparator();
        //REPORTING
        EM em = new EM();
        try {
            long start = System.nanoTime();
            em.setNumExecutionSlots(7);
            em.setMaxIterations(55);
            em.setMinLogLikelihoodImprovementCV(0.0005);
            em.setMinLogLikelihoodImprovementIterating(0.0005);
            em.setMinStdDev(0.0005);
            em.setMaximumNumberOfClusters(25);
            em.setMinStdDev(0.0005);
                em.setNumFolds(5);
                em.setNumKMeansRuns(5);
//                em.setMaxIterations(1);
//                em.setMinStdDev(10);
//                em.setNumClusters(3);
            em.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(em);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("EM");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "EM");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);
            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            myParent.refreshLayersList();
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        //REPORTING
        long endTime = System.nanoTime();
        double elapsed = ((endTime - startTime) / 1000000000);
        double endRAM = (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1024.0;
        double usedRAM = endRAM - startRAM;
        localReport = new ReportResults(date, "EM clustering", startTime, endTime, elapsed, 6, startRAM, endRAM, usedRAM, detailedResults);
        myParent.allData.results.add(localReport);
        myParent.refreshReportList();
        //REPORTING
    }//GEN-LAST:event_runEMActionPerformed

    private void runCanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runCanActionPerformed
        // TODO add your handling code here:
        readData();
        //REPORTING
        String detailedResults = "Running Canopy algorithm on selected mixed layer."+System.lineSeparator();
        Calendar currentDate=Calendar.getInstance();
        Date date=currentDate.getTime();
        double startRAM=(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory())/1024.0;
        long startTime=System.nanoTime();
        //REPORTING
        Canopy canopy = new Canopy();
        try {
            long start = System.nanoTime();
//            canopy.setT1(0.01);
//            canopy.setT2(0.04);
            canopy.buildClusterer(m_Instances);
            ClusterEvaluation eval = new ClusterEvaluation();
            eval.setClusterer(canopy);
            eval.evaluateClusterer(m_Instances);
            String strSummary = eval.clusterResultsToString();
            System.out.println("Canopy");
            System.out.println(strSummary);
            
            //REPORTING
            detailedResults=detailedResults+strSummary+System.lineSeparator();
            //REPORTING
            
            double[] assignments = eval.getClusterAssignments();
            LayerDefinition cluster = new LayerDefinition("category", "canopy");
            cluster.categories = new String[eval.getNumClusters()];
            cluster.values = new double[eval.getNumClusters()];
            cluster.colors = new Color[eval.getNumClusters()];
            for (int i = 0; i < eval.getNumClusters(); i++) {
                cluster.categories[i] = String.valueOf(i);
                cluster.values[i] = i + 1;
                cluster.colors[i] = new Color(Color.HSBtoRGB((float) i / (float) cluster.values.length - 1, 1, 1));
            }
            myParent.allData.all_Layers.add(cluster);
            for (int i = 0; i < myParent.allData.all_Nodes.length; i++) {
                short[] temp = new short[1];
                temp[0] = (short) (assignments[i] + 1);
                myParent.allData.all_Nodes[i].layers.add(temp);
            }
            long end = System.nanoTime();
            System.out.println("Time passed: " + ((end - start) / 1000000000));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        //REPORTING
        long endTime = System.nanoTime();
        double elapsed = ((endTime - startTime) / 1000000000);
        double endRAM = (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1024.0;
        double usedRAM = endRAM - startRAM;
        localReport = new ReportResults(date, "Canopy clustering", startTime, endTime, elapsed, 1, startRAM, endRAM, usedRAM, detailedResults);
        myParent.allData.results.add(localReport);
        myParent.refreshReportList();
        //REPORTING
    }//GEN-LAST:event_runCanActionPerformed

    public double dunnIndexCalc(SimpleKMeans kmeans) {
        Instances c = kmeans.getClusterCentroids();
        double minIntraDist = Double.POSITIVE_INFINITY;
        for (int i = 0; i < c.size(); i++) {
            for (int j = i; j < c.size(); j++) {
                if (distance(c.get(i), c.get(j)) < minIntraDist) {
                    minIntraDist = distance(c.get(i), c.get(j));
                }
            }
        }
        System.out.println("min detected");
        Cluster clusters[] = new Cluster[kmeans.getNumClusters()];
        for (int i = 0; i < clusters.length; i++) {
            clusters[i] = new Cluster(i);
        }
        int assignments[];
        try {
            assignments = kmeans.getAssignments();
            for (int i = 0; i < assignments.length; i++) {
                clusters[assignments[i]].instances.add(m_Instances.get(i));
            }
        } catch (Exception ex) {
            Logger.getLogger(ClusteringDialog.class.getName()).log(Level.SEVERE, null, ex);
        }
        double minInterDist = Double.POSITIVE_INFINITY;
        for (int cl = 0; cl < clusters.length; cl++) {
            for (int i = 0; i < clusters[cl].instances.size(); i++) {
                for (int j = i; j < clusters[cl].instances.size(); j++) {
                    if (distance((Instance) clusters[cl].instances.get(i), (Instance) clusters[cl].instances.get(j)) < minInterDist) {
                        minInterDist = distance((Instance) clusters[cl].instances.get(i), (Instance) clusters[cl].instances.get(j));
                    }
                }
            }
        }
        return minIntraDist / minInterDist;
    }

    public void readData() {
        StringBuilder arffData = new StringBuilder();
        arffData.append("@RELATION data" + "\n");
//        arffData.append("@ATTRIBUTE ").append("lat").append(" numeric").append("\n");
//        arffData.append("@ATTRIBUTE ").append("lon").append(" numeric").append("\n");
        //System.out.println("header: "+myParent.baseDataDetails.headers.length);
        for (int i = 0; i < headers.length - 1; i++) {
            arffData.append("@ATTRIBUTE ").append(headers[i]).append(" numeric").append("\n");
        }
        arffData.append("@DATA").append("\n");

        for (int i = 0; i < data.length; i++) {

            //System.out.println("data columns: "+myParent.baseDataDetails.data[i].length);
            for (int j = 0; j < data[i].length - 1; j++) {
                arffData.append(data[i][j]);
                if (j < data[i].length - 2) {
                    arffData.append(",");
                }
            }
            arffData.append("\n");
        }

        String str = arffData.toString();
        jTextArea1.setText(str);
        // convert String into InputStream
        InputStream is = new ByteArrayInputStream(str.getBytes());

        // read it with BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(is));

        ArffReader arff;
        try {
            arff = new ArffReader(br);
            m_Instances = arff.getData();
            for (int i = 0; i < m_Instances.numInstances(); i++) {
                m_Instances.instance(i).setWeight(Double.parseDouble(data[i][2]));//IMPIMPIMPIMPIMP
//                System.out.println(data[i][2]);
            }
            System.out.println("DATA READY!");
        } catch (IOException | NumberFormatException ex) {
            System.out.println(ex.getMessage());
        }
    }

    public double distance(Instance in1, Instance in2) {
        double temp1[] = in1.toDoubleArray();
        double temp2[] = in2.toDoubleArray();
        double dist = 0;
        for (int i = 0; i < temp1.length; i++) {
            dist = dist + Math.pow(temp1[i] - temp2[i], 2);
        }
        dist = Math.sqrt(dist);
        return dist;
    }

    public void setInstancesFromFileQ() {

        int returnVal = m_FileChooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            if (m_FileChooser.getLoader() == null) {
//	  JOptionPane.showMessageDialog(this,
//			  Messages.getInstance().getString("PreprocessPanel_SetInstancesFromFileQ_JOptionPaneShowMessageDialog_Text_First"),
//			  Messages.getInstance().getString("PreprocessPanel_SetInstancesFromFileQ_JOptionPaneShowMessageDialog_Text_Second"),
//	      JOptionPane.ERROR_MESSAGE);
//	  converterQuery(m_FileChooser.getSelectedFile());
            } else {
                setInstancesFromFile(m_FileChooser.getLoader());
            }

        }
    }

    public void setInstancesFromFile(final AbstractFileLoader loader) {
        Thread m_IOThread = new Thread() {
            public void run() {
            }
        };

        try {
            Instances inst = loader.getDataSet();
            setInstances(inst);
        } catch (Exception ex) {
        }
    }

    public void setInstances(Instances inst) {

        m_Instances = inst;
        int oldIndex = m_Instances.classIndex();

        m_Instances.setClassIndex(oldIndex);

    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTable jTable1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JButton prepareData;
    private javax.swing.JButton runAll;
    private javax.swing.JButton runCKM;
    private javax.swing.JButton runCan;
    private javax.swing.JButton runDBSCAN;
    private javax.swing.JButton runEM;
    private javax.swing.JButton runSOM;
    private javax.swing.JButton runXMeans;
    // End of variables declaration//GEN-END:variables
}
